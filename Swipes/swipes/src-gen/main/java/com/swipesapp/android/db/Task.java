package com.swipesapp.android.db;

import java.util.List;
import com.swipesapp.android.db.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table TASK.
 */
public class Task {

    private Long id;
    private String objectId;
    private String tempId;
    private String parentLocalId;
    private java.util.Date createdAt;
    private java.util.Date updatedAt;
    private Boolean deleted;
    private String title;
    private String notes;
    private Integer order;
    private Integer priority;
    private java.util.Date completionDate;
    private java.util.Date schedule;
    private String location;
    private java.util.Date repeatDate;
    private String repeatOption;
    private String origin;
    private String originIdentifier;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient TaskDao myDao;

    private List<TaskTag> taskTags;
    private List<Attachment> attachments;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public Task() {
    }

    public Task(Long id) {
        this.id = id;
    }

    public Task(Long id, String objectId, String tempId, String parentLocalId, java.util.Date createdAt, java.util.Date updatedAt, Boolean deleted, String title, String notes, Integer order, Integer priority, java.util.Date completionDate, java.util.Date schedule, String location, java.util.Date repeatDate, String repeatOption, String origin, String originIdentifier) {
        this.id = id;
        this.objectId = objectId;
        this.tempId = tempId;
        this.parentLocalId = parentLocalId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.deleted = deleted;
        this.title = title;
        this.notes = notes;
        this.order = order;
        this.priority = priority;
        this.completionDate = completionDate;
        this.schedule = schedule;
        this.location = location;
        this.repeatDate = repeatDate;
        this.repeatOption = repeatOption;
        this.origin = origin;
        this.originIdentifier = originIdentifier;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getTaskDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getObjectId() {
        return objectId;
    }

    public void setObjectId(String objectId) {
        this.objectId = objectId;
    }

    public String getTempId() {
        return tempId;
    }

    public void setTempId(String tempId) {
        this.tempId = tempId;
    }

    public String getParentLocalId() {
        return parentLocalId;
    }

    public void setParentLocalId(String parentLocalId) {
        this.parentLocalId = parentLocalId;
    }

    public java.util.Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(java.util.Date createdAt) {
        this.createdAt = createdAt;
    }

    public java.util.Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(java.util.Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Boolean getDeleted() {
        return deleted;
    }

    public void setDeleted(Boolean deleted) {
        this.deleted = deleted;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public Integer getOrder() {
        return order;
    }

    public void setOrder(Integer order) {
        this.order = order;
    }

    public Integer getPriority() {
        return priority;
    }

    public void setPriority(Integer priority) {
        this.priority = priority;
    }

    public java.util.Date getCompletionDate() {
        return completionDate;
    }

    public void setCompletionDate(java.util.Date completionDate) {
        this.completionDate = completionDate;
    }

    public java.util.Date getSchedule() {
        return schedule;
    }

    public void setSchedule(java.util.Date schedule) {
        this.schedule = schedule;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public java.util.Date getRepeatDate() {
        return repeatDate;
    }

    public void setRepeatDate(java.util.Date repeatDate) {
        this.repeatDate = repeatDate;
    }

    public String getRepeatOption() {
        return repeatOption;
    }

    public void setRepeatOption(String repeatOption) {
        this.repeatOption = repeatOption;
    }

    public String getOrigin() {
        return origin;
    }

    public void setOrigin(String origin) {
        this.origin = origin;
    }

    public String getOriginIdentifier() {
        return originIdentifier;
    }

    public void setOriginIdentifier(String originIdentifier) {
        this.originIdentifier = originIdentifier;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<TaskTag> getTaskTags() {
        if (taskTags == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TaskTagDao targetDao = daoSession.getTaskTagDao();
            List<TaskTag> taskTagsNew = targetDao._queryTask_TaskTags(id);
            synchronized (this) {
                if(taskTags == null) {
                    taskTags = taskTagsNew;
                }
            }
        }
        return taskTags;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetTaskTags() {
        taskTags = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Attachment> getAttachments() {
        if (attachments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AttachmentDao targetDao = daoSession.getAttachmentDao();
            List<Attachment> attachmentsNew = targetDao._queryTask_Attachments(id);
            synchronized (this) {
                if(attachments == null) {
                    attachments = attachmentsNew;
                }
            }
        }
        return attachments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAttachments() {
        attachments = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
