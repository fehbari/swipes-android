package com.swipesapp.android.db;

import java.util.List;
import com.swipesapp.android.db.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
import com.google.gson.annotations.SerializedName;
import com.swipesapp.android.sync.gson.GsonDate;
import com.swipesapp.android.sync.gson.LocalOnly;
// KEEP INCLUDES END
/**
 * Entity mapped to table TASK.
 */
public class Task {

    @LocalOnly
    private Long id;
    private String objectId;
    private String tempId;
    private String parentLocalId;
    @LocalOnly
    private java.util.Date createdAt;
    @LocalOnly
    private java.util.Date updatedAt;
    private Boolean deleted;
    private String title;
    private String notes;
    private Integer order;
    private Integer priority;
    @LocalOnly
    private java.util.Date completionDate;
    @LocalOnly
    private java.util.Date schedule;
    private String location;
    @LocalOnly
    private java.util.Date repeatDate;
    private String repeatOption;
    private String origin;
    private String originIdentifier;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient TaskDao myDao;

    @LocalOnly
    private List<TaskTag> taskTags;
    @LocalOnly
    private List<Attachment> attachments;

    // KEEP FIELDS - put your custom fields here
    private List<Tag> tags;

    @LocalOnly
    private boolean isSelected;

    @SerializedName("createdAt")
    private String syncCreatedAt;

    @SerializedName("updatedAt")
    private String syncUpdatedAt;

    @SerializedName("completionDate")
    private GsonDate syncCompletionDate;

    @SerializedName("schedule")
    private GsonDate syncSchedule;

    @SerializedName("repeatDate")
    private GsonDate syncRepeatDate;
    // KEEP FIELDS END

    public Task() {
    }

    public Task(Long id) {
        this.id = id;
    }

    public Task(Long id, String objectId, String tempId, String parentLocalId, java.util.Date createdAt, java.util.Date updatedAt, Boolean deleted, String title, String notes, Integer order, Integer priority, java.util.Date completionDate, java.util.Date schedule, String location, java.util.Date repeatDate, String repeatOption, String origin, String originIdentifier) {
        this.id = id;
        this.objectId = objectId;
        this.tempId = tempId;
        this.parentLocalId = parentLocalId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.deleted = deleted;
        this.title = title;
        this.notes = notes;
        this.order = order;
        this.priority = priority;
        this.completionDate = completionDate;
        this.schedule = schedule;
        this.location = location;
        this.repeatDate = repeatDate;
        this.repeatOption = repeatOption;
        this.origin = origin;
        this.originIdentifier = originIdentifier;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getTaskDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getObjectId() {
        return objectId;
    }

    public void setObjectId(String objectId) {
        this.objectId = objectId;
    }

    public String getTempId() {
        return tempId;
    }

    public void setTempId(String tempId) {
        this.tempId = tempId;
    }

    public String getParentLocalId() {
        return parentLocalId;
    }

    public void setParentLocalId(String parentLocalId) {
        this.parentLocalId = parentLocalId;
    }

    public java.util.Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(java.util.Date createdAt) {
        this.createdAt = createdAt;
    }

    public java.util.Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(java.util.Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Boolean getDeleted() {
        return deleted;
    }

    public void setDeleted(Boolean deleted) {
        this.deleted = deleted;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public Integer getOrder() {
        return order;
    }

    public void setOrder(Integer order) {
        this.order = order;
    }

    public Integer getPriority() {
        return priority;
    }

    public void setPriority(Integer priority) {
        this.priority = priority;
    }

    public java.util.Date getCompletionDate() {
        return completionDate;
    }

    public void setCompletionDate(java.util.Date completionDate) {
        this.completionDate = completionDate;
    }

    public java.util.Date getSchedule() {
        return schedule;
    }

    public void setSchedule(java.util.Date schedule) {
        this.schedule = schedule;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public java.util.Date getRepeatDate() {
        return repeatDate;
    }

    public void setRepeatDate(java.util.Date repeatDate) {
        this.repeatDate = repeatDate;
    }

    public String getRepeatOption() {
        return repeatOption;
    }

    public void setRepeatOption(String repeatOption) {
        this.repeatOption = repeatOption;
    }

    public String getOrigin() {
        return origin;
    }

    public void setOrigin(String origin) {
        this.origin = origin;
    }

    public String getOriginIdentifier() {
        return originIdentifier;
    }

    public void setOriginIdentifier(String originIdentifier) {
        this.originIdentifier = originIdentifier;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<TaskTag> getTaskTags() {
        if (taskTags == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TaskTagDao targetDao = daoSession.getTaskTagDao();
            List<TaskTag> taskTagsNew = targetDao._queryTask_TaskTags(id);
            synchronized (this) {
                if(taskTags == null) {
                    taskTags = taskTagsNew;
                }
            }
        }
        return taskTags;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetTaskTags() {
        taskTags = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Attachment> getAttachments() {
        if (attachments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AttachmentDao targetDao = daoSession.getAttachmentDao();
            List<Attachment> attachmentsNew = targetDao._queryTask_Attachments(id);
            synchronized (this) {
                if(attachments == null) {
                    attachments = attachmentsNew;
                }
            }
        }
        return attachments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAttachments() {
        attachments = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    public List<Tag> getTags() {
        return tags;
    }

    public void setTags(List<Tag> tags) {
        this.tags = tags;
    }

    public String getSyncCreatedAt() {
        return syncCreatedAt;
    }

    public void setSyncCreatedAt(String syncCreatedAt) {
        this.syncCreatedAt = syncCreatedAt;
    }

    public String getSyncUpdatedAt() {
        return syncUpdatedAt;
    }

    public void setSyncUpdatedAt(String syncUpdatedAt) {
        this.syncUpdatedAt = syncUpdatedAt;
    }

    public String getSyncCompletionDate() {
        return syncCompletionDate != null ? syncCompletionDate.getDate() : null;
    }

    public void setSyncCompletionDate(GsonDate syncCompletionDate) {
        this.syncCompletionDate = syncCompletionDate;
    }

    public String getSyncSchedule() {
        return syncSchedule != null ? syncSchedule.getDate() : null;
    }

    public void setSyncSchedule(GsonDate syncSchedule) {
        this.syncSchedule = syncSchedule;
    }

    public String getSyncRepeatDate() {
        return syncRepeatDate != null ? syncRepeatDate.getDate() : null;
    }

    public void setSyncRepeatDate(GsonDate syncRepeatDate) {
        this.syncRepeatDate = syncRepeatDate;
    }

    public Boolean isDeleted() {
        return deleted;
    }

    public boolean isSelected() {
        return isSelected;
    }

    public void setSelected(boolean isSelected) {
        this.isSelected = isSelected;
    }

    public void setAttachments(List<Attachment> attachments) {
        this.attachments = attachments;
    }

    public void addAttachment(Attachment attachment) {
        attachments.add(attachment);
    }

    public void removeAttachment(Attachment attachmentToRemove) {
        if (attachments != null) {
            Attachment match = null;

            for (Attachment attachment : attachments) {
                Long id = attachment.getId();
                String identifier = attachment.getIdentifier();

                if (id.equals(attachmentToRemove.getId()) || identifier.equals(attachmentToRemove.getIdentifier())) {
                    match = attachment;
                }
            }

            attachments.remove(match);
        }
    }

    public Attachment getFirstAttachmentForService(String service) {
        Attachment match = null;
        if (attachments != null) {
            for (Attachment attachment : attachments) {
                if (service.equals(attachment.getService())) {
                    match = attachment;
                    break;
                }
            }
        }
        return match;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj != null && obj instanceof Task) {
            if (((Task) obj).getTempId().equals(tempId)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public int hashCode() {
        return tempId.hashCode();
    }
    // KEEP METHODS END

}
